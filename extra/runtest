#!/bin/bash

set -e

# Limit to 1G of virtual memory
ulimit -v 1000000

CMDDIR=`pwd`
TOP_SRCDIR=`pwd`/`dirname $0`/..
PYTHON=${PYTHON:-python}

## Run under eatmydata if available

libeatmydata="/usr/lib/libeatmydata/libeatmydata.so"
if [ -e $libeatmydata ]
then
    if [ -n "$LD_PRELOAD" ]; then
        export LD_PRELOAD="$libeatmydata $LD_PRELOAD"
    else
        export LD_PRELOAD="$libeatmydata"
    fi
fi


## Set up the test environment

export WREPORT_EXTRA_TABLES=$TOP_SRCDIR/tables
export WREPORT_TESTDATA=$TOP_SRCDIR/extra
export DBA_REPINFO=$TOP_SRCDIR/tables/repinfo.csv
export DBA_TABLES=$TOP_SRCDIR/tables
export DBA_TESTDATA=$TOP_SRCDIR/extra
export DBA_INSECURE_SQLITE=1

TESTDIR="`mktemp -d`"
cd "$TESTDIR"

touch test.sqlite

## Clean up the test environment at exit unless asked otherwise
cleanup() {
    if [ ! -z "$PAUSE" ]
    then
        echo "Post-test inspection requested."
        echo "Exit this shell to cleanup the test environment."
        bash
    fi

    test -z "$PRESERVE" && rm -rf "$TESTDIR"
}
trap cleanup EXIT

#id=`date +%y%m%d%H%M%S`
#$DEBUGGER $BIN $ARGS 2>&1 | tee `pwd`/testrun-$id
#echo Output saved in `pwd`/testrun-$id

# Try to debug the libtool executable, if present
RES=0
for cmd in "$@"
do
    CMD="$CMDDIR/$cmd"
    DIR=`dirname $CMD`
    BASE=`basename $CMD`
    if [ "${BASE##*.}" = "py" ]
    then
        CMD="$PYTHON $CMD"
    fi
    if [ ! -z "$DEBUGGER" ]
    then
        echo "Running $DEBUGGER $CMD $ARGS"
        if ! libtool --mode=execute $DEBUGGER $CMD $ARGS
        then
            RES=$?
            echo "Failed with result $RES"
        fi
    else
        echo "Running $CMD $ARGS"
        if $CMD $ARGS
        then
            true
        else
            RES=$?
            echo "Failed with result $RES"
        fi
    fi
done

exit $RES
